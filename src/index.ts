/* eslint-disable @typescript-eslint/camelcase */

import { getInput, setFailed } from '@actions/core';
import { context } from '@actions/github';
import { Octokit } from '@octokit/action';

import { isGitHubActions, debug } from './lib/actions';
import { hasLockfile, isNpm, isYarn } from './package-manager';
import { getOutdatedPackages } from './outdated';
import { getUnusedPackages } from './unused';

const commentHeader = '<!-- packageCheckupAction comment -->';

const getMessage = async (): Promise<string> => {
  const lines = [];

  if (hasLockfile()) {
    if (getInput('showOutdatedPackages') !== 'false') {
      const outdatedPackages = await getOutdatedPackages();

      debug('outdatedPackages');
      debug(outdatedPackages);
      lines.push(outdatedPackages);
    }

    if (getInput('showUnusedPackages') !== 'false') {
      const unusedPackages = await getUnusedPackages();

      debug('unusedPackages');
      debug(unusedPackages);

      if (unusedPackages) {
        lines.push(unusedPackages);
      }
    }

    if (lines.length === 0) {
      lines.push('Nothing to do. Check your configuration.');
    }
  } else {
    lines.push(
      'No lockfile found. Package Checkup requires either a `package-lock.json` or `yarn.lock` file.'
    );
  }

  if (isNpm()) {
    lines.unshift(commentHeader, '## Package Checkup', '> Found `package-lock.json`, using npm.');
  } else if (isYarn()) {
    lines.unshift(commentHeader, '## Package Checkup', '> Found `yarn.lock`, using Yarn.');
  } else {
    setFailed('No lockfile');
  }

  lines.push('_Report generated by [Package Checkup](https://packagecheckup.com)_');

  return lines.join('\n\n');
};

const run = async (): Promise<void> => {
  if (!isGitHubActions()) {
    console.log(await getMessage());

    return;
  }

  try {
    if (context.payload.pull_request == null) {
      setFailed('No pull request found');

      return;
    }

    const githubRepo = process.env.GITHUB_REPOSITORY;

    if (!githubRepo) {
      setFailed('No repo found');

      return;
    }

    const message = await getMessage();
    const [owner, repo] = githubRepo.split('/');
    const pullRequestNumber = context.payload.pull_request.number;
    // const githubToken = getInput('token');
    const octokit = new Octokit();
    const comments = await octokit.issues.listCommentsForRepo({ owner, repo });
    const existingComment = comments.data.find(comment => comment.body.startsWith(commentHeader));

    if (existingComment) {
      octokit.issues.updateComment({
        ...context.repo,
        comment_id: existingComment.id,
        body: message
      });
    } else {
      octokit.issues.createComment({
        ...context.repo,
        issue_number: pullRequestNumber,
        body: message
      });
    }
  } catch (error) {
    setFailed(error.message);
  }
};

run();
